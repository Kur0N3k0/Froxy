package proxy

import (
	"bufio"
	"bytes"
	"compress/flate"
	"compress/gzip"
	"compress/zlib"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math/big"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/andybalholm/brotli"
	"github.com/valyala/fasthttp"
)

type contextKey struct {
	key string
}

var ConnContextKey = &contextKey{"http-conn"}

func SaveConnInContext(ctx context.Context, c net.Conn) context.Context {
	return context.WithValue(ctx, ConnContextKey, c)
}
func GetConn(r *http.Request) net.Conn {
	return r.Context().Value(ConnContextKey).(net.Conn)
}

type rootCert struct {
	certkey []byte
	cacrt   []byte
	cakey   []byte
}

type ProxyHistory struct {
	ServerIp       string
	TLS            bool
	RequestMethod  string
	RequestHost    string
	RequestURL     string
	ResponseLength int64
	ResponseStatus int
	RawRequest     []byte
	RawResponse    []byte
}

var root rootCert
var certs map[string][]byte = make(map[string][]byte)
var callback func(ProxyHistory)
var clog func(string)
var History []ProxyHistory = make([]ProxyHistory, 0)
var historyMutex sync.Mutex

func genCert(host string) {
	certKeyPem, _ := pem.Decode(root.certkey)
	certKey, err := x509.ParsePKCS8PrivateKey(certKeyPem.Bytes)
	if err != nil {
		clog("ParsePKCS8PrivateKey: " + err.Error())
	}

	clientCert := x509.Certificate{
		SerialNumber: big.NewInt(9505),
		Subject: pkix.Name{
			CommonName: host,
		},
		DNSNames:              []string{host},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(time.Hour * 24 * 365),
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	block, _ := pem.Decode(root.cacrt)
	caCert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		clog("ParseCertificate: " + err.Error())
		clog("ParseCertificate Failure")
		return
	}

	caKeyPem, _ := pem.Decode(root.cakey)
	caKey, err := x509.ParsePKCS8PrivateKey(caKeyPem.Bytes)
	if err != nil {
		clog("ParsePKCS8PrivateKey: " + err.Error())
	}
	cert, err := x509.CreateCertificate(rand.Reader, &clientCert, caCert, certKey.(*rsa.PrivateKey).Public(), caKey)
	if err != nil {
		clog("CreateCertificate: " + err.Error())
		fmt.Println("CreateCertificate Failure")
		return
	}

	out := &bytes.Buffer{}
	pem.Encode(out, &pem.Block{Type: "CERTIFICATE", Bytes: cert})
	certs[host] = out.Bytes()
}

func handleTunneling(ctx *fasthttp.RequestCtx) {
	ctxHost := string(ctx.Host())
	host := strings.Split(ctxHost, ":")[0]
	fmt.Println("Tunneling:", host)

	dest_conn, err := tls.Dial("tcp", ctxHost, &tls.Config{InsecureSkipVerify: true})
	if err != nil {
		clog("tls.Dial: " + err.Error())
		ctx.Error(err.Error(), http.StatusServiceUnavailable)
		return
	}

	if _, ok := certs[host]; !ok {
		genCert(host)
	}

	cert, err := tls.X509KeyPair(certs[host], root.certkey)
	if err != nil {
		clog("server: loadkeys: " + err.Error())
	}
	config := tls.Config{Certificates: []tls.Certificate{cert}}

	ctx.SetStatusCode(http.StatusOK)

	ctx.Hijack(func(server net.Conn) {
		client_conn := tls.Server(server, &config)
		client_conn.Handshake()

		defer dest_conn.Close()
		defer client_conn.Close()

		clientReader := bufio.NewReader(client_conn)
		for {
			req, err := http.ReadRequest(clientReader)
			if err == io.EOF {
				break
			} else if err != nil {
				clog("Error reading from client: " + err.Error())
				return
			}

			body, _ := ioutil.ReadAll(req.Body)
			contentEncoding := req.Header.Get("Content-Encoding")
			if contentEncoding != "" {
				clog(contentEncoding)
				contentEncoding = strings.ReplaceAll(contentEncoding, " ", "")
				encodedBody := ioutil.NopCloser(bytes.NewReader(body))
				encodings := strings.Split(contentEncoding, ",")
				for _, encoding := range encodings {
					decodedBody, err := DecodeBody(encodedBody, strings.TrimSpace(encoding))
					if err != nil {
						fmt.Printf("Error decoding body: %v\n", err)
						break
					}
					defer decodedBody.Close()

					body, err = ioutil.ReadAll(decodedBody)
					if err != nil {
						fmt.Printf("Error reading decoded body: %v\n", err)
						break
					}
					encodedBody = ioutil.NopCloser(bytes.NewReader(body))
				}
			}

			delete(req.Header, "Transfer-Encoding")
			delete(req.Header, "Content-Encoding")

			req.Body = ioutil.NopCloser(bytes.NewReader(body))
			req.ContentLength = int64(len(body))
			rawReq := logRequest(req)

			if err := req.Write(dest_conn); err != nil {
				clog("Error forwarding request to destination: " + err.Error())
				return
			}

			res, err := http.ReadResponse(bufio.NewReader(dest_conn), req)
			if err != nil {
				clog("Error reading response from destination: %v" + err.Error())
				return
			}

			body, _ = ioutil.ReadAll(res.Body)
			contentEncoding = res.Header.Get("Content-Encoding")
			if contentEncoding != "" {
				clog(contentEncoding)
				contentEncoding = strings.ReplaceAll(contentEncoding, " ", "")
				encodedBody := ioutil.NopCloser(bytes.NewReader(body))
				encodings := strings.Split(contentEncoding, ",")
				for _, encoding := range encodings {
					decodedBody, err := DecodeBody(encodedBody, strings.TrimSpace(encoding))
					if err != nil {
						fmt.Printf("Error decoding body: %v\n", err)
						break
					}
					defer decodedBody.Close()

					body, err = ioutil.ReadAll(decodedBody)
					if err != nil {
						fmt.Printf("Error reading decoded body: %v\n", err)
						break
					}
					encodedBody = ioutil.NopCloser(bytes.NewReader(body))
				}
			}

			delete(res.Header, "Transfer-Encoding")
			delete(res.Header, "Content-Encoding")

			newResponse := &http.Response{
				Status:           res.Status,
				StatusCode:       res.StatusCode,
				Proto:            res.Proto,
				ProtoMajor:       res.ProtoMajor,
				ProtoMinor:       res.ProtoMinor,
				Header:           res.Header.Clone(),
				Body:             ioutil.NopCloser(bytes.NewReader(body)),
				ContentLength:    int64(len(body)),
				TransferEncoding: nil,
				Close:            false,
				Uncompressed:     true,
				Request:          res.Request,
				TLS:              res.TLS,
			}
			res.Body = ioutil.NopCloser(bytes.NewReader(body))
			res.ContentLength = int64(len(body))

			rawRes := logResponse(newResponse)
			if err := newResponse.Write(client_conn); err != nil {
				log.Printf("Error forwarding response to client: %v", err)
				return
			}

			hostname := string(ctx.Host())
			history := ProxyHistory{
				ServerIp:       hostname,
				TLS:            true,
				RequestMethod:  req.Method,
				RequestHost:    hostname,
				RequestURL:     req.URL.RequestURI(),
				ResponseLength: newResponse.ContentLength,
				ResponseStatus: newResponse.StatusCode,
				RawRequest:     rawReq,
				RawResponse:    rawRes,
			}
			historyMutex.Lock()
			History = append(History, history)
			historyMutex.Unlock()
			callback(history)
		}
	})
}

func logRequest(req *http.Request) []byte {
	dump, err := httputil.DumpRequest(req, true)
	if err != nil {
		clog("Error dumping request: " + err.Error())
		return nil
	}

	log.Println("Request:")
	log.Println(string(dump))
	return dump
}

func logResponse(res *http.Response) []byte {
	dump, err := httputil.DumpResponse(res, true)
	if err != nil {
		log.Printf("Error dumping response: %v", err)
		return nil
	}

	log.Println("Response:")
	log.Println(string(dump))
	return dump
}

func DecodeBody(encodedBody io.ReadCloser, encoding string) (io.ReadCloser, error) {
	switch encoding {
	case "gzip":
		return gzip.NewReader(encodedBody)
	case "deflate":
		return flate.NewReader(encodedBody), nil
	case "zlib":
		return zlib.NewReader(encodedBody)
	case "br":
		return ioutil.NopCloser(brotli.NewReader(encodedBody)), nil
	default:
		return nil, fmt.Errorf("unsupported content encoding: %s", encoding)
	}
}

func handleHTTP(ctx *fasthttp.RequestCtx) {
	resp := fasthttp.AcquireResponse()
	defer fasthttp.ReleaseResponse(resp)

	if err := fasthttp.Do(&ctx.Request, resp); err != nil {
		ctx.Error(err.Error(), http.StatusServiceUnavailable)
		return
	}

	body := resp.Body()

	contentEncoding := string(resp.Header.Peek("Content-Encoding"))
	if contentEncoding != "" {
		clog(contentEncoding)
		contentEncoding = strings.ReplaceAll(contentEncoding, " ", "")
		encodedBody := ioutil.NopCloser(bytes.NewReader(body))
		encodings := strings.Split(contentEncoding, ",")
		for _, encoding := range encodings {
			decodedBody, err := DecodeBody(encodedBody, strings.TrimSpace(encoding))
			if err != nil {
				clog("Error decoding body: " + err.Error())
				break
			}
			defer decodedBody.Close()

			body, err = ioutil.ReadAll(decodedBody)
			if err != nil {
				clog("Error reading decoded body: " + err.Error())
				break
			}
			encodedBody = ioutil.NopCloser(bytes.NewReader(body))
		}
	}

	resp.Header.Del("Transfer-Encoding")
	resp.Header.Del("Content-Encoding")
	resp.Header.Set("Content-Length", strconv.Itoa(len(body)))

	newResponse := &http.Response{}
	newResponse.StatusCode = resp.StatusCode()
	newResponse.Header = http.Header{}
	resp.Header.VisitAll(func(key, value []byte) {
		newResponse.Header.Add(string(key), string(value))
	})
	newResponse.Body = ioutil.NopCloser(bytes.NewReader(resp.Body()))

	req := &http.Request{}
	req.Method = string(ctx.Request.Header.Method())
	req.URL = &url.URL{
		Scheme: string(ctx.Request.URI().Scheme()),
		Host:   string(ctx.Request.URI().Host()),
		Path:   string(ctx.Request.URI().Path()),
	}
	req.Proto = string(ctx.Request.Header.Protocol())
	req.Header = http.Header{}
	ctx.Request.Header.VisitAll(func(key, value []byte) {
		req.Header.Add(string(key), string(value))
	})
	req.Body = ioutil.NopCloser(bytes.NewReader(ctx.Request.Body()))

	rawRaw := logRequest(req)
	rawRes := logResponse(newResponse)

	curhis := ProxyHistory{
		ServerIp:       req.Host,
		TLS:            false,
		RequestMethod:  req.Method,
		RequestHost:    req.Host,
		RequestURL:     req.URL.RequestURI(),
		ResponseLength: int64(len(body)),
		ResponseStatus: newResponse.StatusCode,
		RawRequest:     rawRaw,
		RawResponse:    rawRes,
	}
	historyMutex.Lock()
	History = append(History, curhis)
	callback(curhis)
	historyMutex.Unlock()

	log.Println(req.RemoteAddr, " ", resp.StatusCode())

	ctx.Response.SetStatusCode(resp.StatusCode())
	resp.Header.VisitAll(func(key, value []byte) {
		ctx.Response.Header.SetBytesKV(key, value)
	})
	ctx.Response.SetBody(resp.Body())
}

func init() {
	root.cacrt = []byte(`__CA_CRT__`)
	root.cakey = []byte(`__CA_KEY__`)
	root.certkey = []byte(`__CERT_KEY__`)
}

func RunProxy(addr string, cb func(ProxyHistory), flog func(string)) {
	callback = cb
	clog = flog

	fasthttp.ListenAndServe(":9505", func(ctx *fasthttp.RequestCtx) {
		if string(ctx.Method()) == http.MethodConnect {
			handleTunneling(ctx)
		} else {
			handleHTTP(ctx)
		}
	})
}
