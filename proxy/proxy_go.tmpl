package proxy

import (
	"bufio"
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"log"
	"math/big"
	"net"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/andybalholm/brotli"
	"github.com/valyala/fasthttp"
)

type contextKey struct {
	key string
}

var ConnContextKey = &contextKey{"http-conn"}

func SaveConnInContext(ctx context.Context, c net.Conn) context.Context {
	return context.WithValue(ctx, ConnContextKey, c)
}
func GetConn(r *http.Request) net.Conn {
	return r.Context().Value(ConnContextKey).(net.Conn)
}

type rootCert struct {
	certkey []byte
	cacrt   []byte
	cakey   []byte
}

type ProxyHistory struct {
	ServerIp       string
	TLS            bool
	RequestMethod  string
	RequestHost    string
	RequestURL     string
	ResponseLength int64
	ResponseStatus int
	RawRequest     []byte
	RawResponse    []byte
}

var root rootCert
var certs map[string][]byte = make(map[string][]byte)
var callback func(ProxyHistory)
var clog func(string)
var History []ProxyHistory = make([]ProxyHistory, 0)
var historyMutex sync.Mutex

func genCert(host string) {
	certKeyPem, _ := pem.Decode(root.certkey)
	certKey, err := x509.ParsePKCS8PrivateKey(certKeyPem.Bytes)
	if err != nil {
		clog("ParsePKCS8PrivateKey: " + err.Error())
	}

	clientCert := x509.Certificate{
		SerialNumber: big.NewInt(9505),
		Subject: pkix.Name{
			CommonName: host,
		},
		DNSNames:              []string{host},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().Add(time.Hour * 24 * 365),
		KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
		ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
		BasicConstraintsValid: true,
	}

	block, _ := pem.Decode(root.cacrt)
	caCert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		clog("ParseCertificate: " + err.Error())
		clog("ParseCertificate Failure")
		return
	}

	caKeyPem, _ := pem.Decode(root.cakey)
	caKey, err := x509.ParsePKCS8PrivateKey(caKeyPem.Bytes)
	if err != nil {
		clog("ParsePKCS8PrivateKey: " + err.Error())
	}
	cert, err := x509.CreateCertificate(rand.Reader, &clientCert, caCert, certKey.(*rsa.PrivateKey).Public(), caKey)
	if err != nil {
		clog("CreateCertificate: " + err.Error())
		fmt.Println("CreateCertificate Failure")
		return
	}

	out := &bytes.Buffer{}
	pem.Encode(out, &pem.Block{Type: "CERTIFICATE", Bytes: cert})
	certs[host] = out.Bytes()
}

func fasthttpRequestToHTTPRequest(req *fasthttp.Request) (*http.Request, error) {
	u := url.URL{
		Scheme:   string(req.URI().Scheme()),
		Host:     string(req.URI().Host()),
		Path:     string(req.URI().Path()),
		RawQuery: string(req.URI().QueryString()),
	}

	body := bytes.NewReader(req.Body())
	httpReq, err := http.NewRequest(string(req.Header.Method()), u.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.VisitAll(func(key, value []byte) {
		httpReq.Header.Set(string(key), string(value))
	})

	return httpReq, nil
}

func fasthttpResponseToHTTPResponse(resp *fasthttp.Response) (*http.Response, error) {
	// contentLength := int64(0)
	// if resp.Header.ContentLength() > 0 {
	// 	contentLength = int64(resp.Header.ContentLength())
	// }

	httpResp := &http.Response{
		Status:           string(resp.Header.StatusMessage()),
		StatusCode:       resp.StatusCode(),
		Header:           make(http.Header),
		Body:             ioutil.NopCloser(bytes.NewReader(resp.Body())),
		ContentLength:    int64(len(resp.Body())),
		TransferEncoding: nil,
		Close:            resp.ConnectionClose(),
		Uncompressed:     true,
	}

	resp.Header.VisitAll(func(key, value []byte) {
		httpResp.Header.Set(string(key), string(value))
	})

	httpResp.Proto = string(resp.Header.Protocol())

	proto := string(resp.Header.Protocol())
	parts := strings.SplitN(string(proto), "/", 2)
	if len(parts) == 2 {
		httpResp.Proto = parts[1]
		majMin := strings.SplitN(parts[1], ".", 2)
		if len(majMin) == 2 {
			major, err := strconv.Atoi(majMin[0])
			if err == nil {
				httpResp.ProtoMajor = major
			}
			minor, err := strconv.Atoi(majMin[1])
			if err == nil {
				httpResp.ProtoMinor = minor
			}
		}
	}

	return httpResp, nil
}

func handleTunneling(ctx *fasthttp.RequestCtx) {
	ctxHost := string(ctx.Host())
	host := strings.Split(ctxHost, ":")[0]
	fmt.Println("Tunneling:", host)

	dest_conn, err := tls.Dial("tcp", ctxHost, &tls.Config{InsecureSkipVerify: true})
	if err != nil {
		clog("tls.Dial: " + err.Error())
		ctx.Error(err.Error(), http.StatusServiceUnavailable)
		return
	}

	if _, ok := certs[host]; !ok {
		genCert(host)
	}

	cert, err := tls.X509KeyPair(certs[host], root.certkey)
	if err != nil {
		clog("server: loadkeys: " + err.Error())
	}
	config := tls.Config{Certificates: []tls.Certificate{cert}}

	ctx.SetStatusCode(http.StatusOK)
	ctx.Hijack(func(server net.Conn) {
		client_conn := tls.Server(server, &config)
		client_conn.Handshake()

		defer dest_conn.Close()
		defer client_conn.Close()

		clientReader := bufio.NewReader(client_conn)
		destReader := bufio.NewReaderSize(dest_conn, 64*1024)

		for {
			req := fasthttp.AcquireRequest()
			defer fasthttp.ReleaseRequest(req)

			err := req.Read(clientReader)
			if err != nil {
				clog("Error reading from client: " + err.Error())
				return
			}

			body := req.Body()
			contentEncoding := string(req.Header.ContentEncoding())
			if contentEncoding != "" {
				clog(contentEncoding)
				body = DecodeBodyAll(contentEncoding, body)
			}

			req.Header.Del("Transfer-Encoding")
			req.Header.Del("Content-Encoding")

			if len(body) > 0 {
				req.SetBody(body)
				req.Header.SetContentLength(len(body))
			}
			hreq, err := fasthttpRequestToHTTPRequest(req)
			if err != nil {
				clog("fasthttpRequestToHTTPRequest: " + err.Error())
				return
			}
			rawReq := logRequest(hreq)

			if err := hreq.Write(dest_conn); err != nil {
				clog("Error forwarding request to destination: " + err.Error())
				return
			}

			res := fasthttp.AcquireResponse()
			defer fasthttp.ReleaseResponse(res)

			err = res.Read(destReader)
			if err != nil {
				clog("Error reading from server: " + err.Error() + "\n" + string(rawReq))
				return
			}

			body = res.Body()

			contentEncoding = string(res.Header.ContentEncoding())
			if contentEncoding != "" {
				clog(contentEncoding)
				body = DecodeBodyAll(contentEncoding, body)
			}

			res.Header.Del("Transfer-Encoding")
			res.Header.Del("Content-Encoding")

			if len(body) > 0 {
				res.SetBody(body)
				res.Header.SetContentLength(len(body))
			}

			hres, err := fasthttpResponseToHTTPResponse(res)
			if err != nil {
				clog("fasthttpResponseToHTTPResponse: " + err.Error())
				return
			}

			rawRes := logResponse(hres)
			if err := hres.Write(client_conn); err != nil {
				clog("Error forwarding response to client: " + err.Error())
				return
			}

			hostname := string(ctx.Host())
			history := ProxyHistory{
				ServerIp:       hostname,
				TLS:            true,
				RequestMethod:  hreq.Method,
				RequestHost:    hostname,
				RequestURL:     hreq.URL.RequestURI(),
				ResponseLength: hres.ContentLength,
				ResponseStatus: hres.StatusCode,
				RawRequest:     rawReq,
				RawResponse:    rawRes,
			}
			historyMutex.Lock()
			History = append(History, history)
			historyMutex.Unlock()
			callback(history)
		}
	})
}

func logRequest(req *http.Request) []byte {
	dump, err := httputil.DumpRequest(req, true)
	if err != nil {
		clog("Error dumping request: " + err.Error())
		return nil
	}

	log.Println("Request:")
	log.Println(string(dump))
	return dump
}

func logResponse(res *http.Response) []byte {
	dump, err := httputil.DumpResponse(res, true)
	if err != nil {
		log.Printf("Error dumping response: %v", err)
		return nil
	}

	log.Println("Response:")
	log.Println(string(dump))
	return dump
}

func DecodeBodyAll(contentEncoding string, body []byte) []byte {
	contentEncoding = strings.ReplaceAll(contentEncoding, " ", "")
	encodings := strings.Split(contentEncoding, ",")
	for _, encoding := range encodings {
		result, err := DecodeBody(body, strings.TrimSpace(encoding))
		if err != nil {
			clog("Error decoding body: " + err.Error())
			break
		}
		body = result
	}
	return body
}

func DecodeBody(body []byte, encoding string) ([]byte, error) {
	switch encoding {
	case "gzip":
		return fasthttp.AppendGunzipBytes(nil, body)
	case "deflate":
		return fasthttp.AppendInflateBytes(nil, body)
	case "br":
		reader := brotli.NewReader(bytes.NewReader(body))
		return ioutil.ReadAll(reader)
	default:
		return nil, fmt.Errorf("unsupported content encoding: %s", encoding)
	}
}

func handleHTTP(ctx *fasthttp.RequestCtx) {
	resp := fasthttp.AcquireResponse()
	defer fasthttp.ReleaseResponse(resp)

	if err := fasthttp.Do(&ctx.Request, resp); err != nil {
		ctx.Error(err.Error(), http.StatusServiceUnavailable)
		return
	}

	contentEncoding := string(ctx.Request.Header.ContentEncoding())
	if contentEncoding != "" {
		clog(contentEncoding)
		result := DecodeBodyAll(contentEncoding, ctx.Request.Body())
		ctx.Request.SetBody(result)
		ctx.Request.Header.SetContentLength(len(result))
	}

	req, err := fasthttpRequestToHTTPRequest(&ctx.Request)
	if err != nil {
		clog(err.Error())
	}

	body := resp.Body()

	contentEncoding = string(resp.Header.Peek("Content-Encoding"))
	if contentEncoding != "" {
		clog(contentEncoding)
		body = DecodeBodyAll(contentEncoding, body)
	}

	resp.Header.Del("Transfer-Encoding")
	resp.Header.Del("Content-Encoding")
	resp.Header.Set("Content-Length", strconv.Itoa(len(body)))
	resp.SetBody(body)

	newResponse, err := fasthttpResponseToHTTPResponse(resp)
	if err != nil {
		clog(err.Error())
	}

	rawReq := logRequest(req)
	rawRes := logResponse(newResponse)

	curhis := ProxyHistory{
		ServerIp:       string(ctx.Host()),
		TLS:            false,
		RequestMethod:  string(ctx.Method()),
		RequestHost:    string(ctx.Host()),
		RequestURL:     ctx.URI().String(),
		ResponseLength: int64(len(body)),
		ResponseStatus: newResponse.StatusCode,
		RawRequest:     rawReq,
		RawResponse:    rawRes,
	}
	historyMutex.Lock()
	History = append(History, curhis)
	callback(curhis)
	historyMutex.Unlock()

	log.Println(req.RemoteAddr, " ", resp.StatusCode())

	ctx.Response.SetStatusCode(resp.StatusCode())
	ctx.Response.Header.SetProtocol(resp.Header.Protocol())
	resp.Header.VisitAll(func(key, value []byte) {
		ctx.Response.Header.SetBytesKV(key, value)
	})
	ctx.Response.SetBody(resp.Body())
}

func init() {
	root.cacrt = []byte(`__CA_CRT__`)
	root.cakey = []byte(`__CA_KEY__`)
	root.certkey = []byte(`__CERT_KEY__`)
}

func RunProxy(addr string, cb func(ProxyHistory), flog func(string)) {
	callback = cb
	clog = flog

	fasthttp.ListenAndServe(":9505", func(ctx *fasthttp.RequestCtx) {
		if string(ctx.Method()) == http.MethodConnect {
			handleTunneling(ctx)
		} else {
			handleHTTP(ctx)
		}
	})
}
